

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Constructing Embedded Boundaries in MFiX-Exa &mdash; MFiX-Exa  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="MFiX-Exa  documentation" href="index.html"/>
        <link rel="up" title="Embedded Boundaries" href="EB.html"/>
        <link rel="prev" title="Embedded Boundaries" href="EB.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> MFiX-Exa
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">MFiX-Exa Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fluids.html">Solving the Fluid Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Particles</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="EB.html">Embedded Boundaries</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Constructing Embedded Boundaries in MFiX-Exa</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#how-mfix-exa-constructs-the-eb-geometry">How MFiX-Exa Constructs the EB Geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mfix-s-eb-data-structures">MFiX’s EB Data Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-note-about-constructing-eb-levels">A note about constructing EB Levels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#local-mesh-refinement-at-walls">Local Mesh Refinement at Walls</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mfix-exa-initialization-process">MFiX-Exa Initialization Process</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-level-set-function">The Level-Set Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#special-cases-involving-level-sets">Special Cases Involving Level-Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fluid-reconstruction">Fluid Reconstruction</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MFiX-Exa</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="EB.html">Embedded Boundaries</a> &raquo;</li>
        
      <li>Constructing Embedded Boundaries in MFiX-Exa</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/EBWalls.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="constructing-embedded-boundaries-in-mfix-exa">
<span id="sec-eb-basics"></span><h1>Constructing Embedded Boundaries in MFiX-Exa<a class="headerlink" href="#constructing-embedded-boundaries-in-mfix-exa" title="Permalink to this headline">¶</a></h1>
<p>MFiX uses AMReX’s constructive solid geometry framework defined in the namespace
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">EB2</span></span></code>. See the <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/EB_Chapter.html">AMReX EB documentation</a> for more details. These are
defined in <code class="docutils literal"><span class="pre">src/eb/mfix_eb.cpp</span></code>. A the function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">make_eb_geometry</span></span></code>
(also defined in <code class="docutils literal"><span class="pre">src/eb/mfix_eb.cpp</span></code>) selects :cpp:one of the following
geometries depending on the value of the :cpp:<code class="docutils literal"><span class="pre">mfix.geometry</span></code> setting in the
<code class="docutils literal"><span class="pre">inputs</span></code> file.</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="29%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head"><code class="docutils literal"><span class="pre">mfix.geometry</span></code></th>
<th class="head">Implementation Satus</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Planar walls from mfix.dat
(on by default)</td>
<td>Don’t specify</td>
<td>Fully implemented</td>
</tr>
<tr class="row-odd"><td>Box (up to six walls)</td>
<td><code class="docutils literal"><span class="pre">box</span></code></td>
<td>Fully implemented</td>
</tr>
<tr class="row-even"><td>Cylinder</td>
<td><code class="docutils literal"><span class="pre">cylinder</span></code></td>
<td>Fully implemented</td>
</tr>
<tr class="row-odd"><td>Hopper</td>
<td><code class="docutils literal"><span class="pre">hopper</span></code></td>
<td>Fully implemented</td>
</tr>
<tr class="row-even"><td>Cyclone</td>
<td><code class="docutils literal"><span class="pre">cyclone</span></code></td>
<td>Fully implemented</td>
</tr>
<tr class="row-odd"><td>General</td>
<td><code class="docutils literal"><span class="pre">general</span></code>
cf. note 1 below</td>
<td>Partially implemented</td>
</tr>
<tr class="row-even"><td>Hourglass</td>
<td><code class="docutils literal"><span class="pre">hourglass</span></code>
cf. note 1</td>
<td>Deprecated
cf. note 2 below</td>
</tr>
<tr class="row-odd"><td>CLR (chemical looping
reactor)</td>
<td><code class="docutils literal"><span class="pre">clr</span></code>
cf. note 1</td>
<td>Deprecated
cf. note 2</td>
</tr>
<tr class="row-even"><td>CLR Riser</td>
<td><code class="docutils literal"><span class="pre">clr_riser</span></code>
cf. note 1</td>
<td>Deprecated
cf. note 2</td>
</tr>
</tbody>
</table>
<ol class="arabic">
<li><p class="first">Older (legacy) alternative settings are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value of  <code class="docutils literal"><span class="pre">mfix.geometry</span></code></th>
<th class="head">Alternative</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">general</span></code></td>
<td><code class="docutils literal"><span class="pre">mfix.use_poly2</span> <span class="pre">=</span> <span class="pre">true</span></code>
or <code class="docutils literal"><span class="pre">mfix.use_walls</span> <span class="pre">=</span> <span class="pre">true</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">hourglass</span></code></td>
<td><code class="docutils literal"><span class="pre">mfix.hourglass</span> <span class="pre">=</span> <span class="pre">true</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">clr</span></code></td>
<td><code class="docutils literal"><span class="pre">mfix.clr</span> <span class="pre">=</span> <span class="pre">true</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">clr_riser</span></code></td>
<td><code class="docutils literal"><span class="pre">mfix.clr_riser</span> <span class="pre">=</span> <span class="pre">true</span></code></td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">These geometries where not ported from AMReX’s old :cpp:<code class="docutils literal"><span class="pre">EB</span></code> system to the
new :cpp:<code class="docutils literal"><span class="pre">EB2</span></code>.</p>
</li>
</ol>
<p>Also note that planar boundary conditions can be specified in the <code class="docutils literal"><span class="pre">mfix.dat</span></code>
file. Even if the user does not specify an <code class="docutils literal"><span class="pre">mfix.geometry</span></code> in the <code class="docutils literal"><span class="pre">inputs</span></code>,
any no-slip or free-slip boundary conditions are expressed as EB walls.</p>
<p>There are also two parameters (specified in the <code class="docutils literal"><span class="pre">inputs</span></code> file) that influence
the level-set creation:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">amr.max_level</span></code></td>
<td>If greater than 1, MFiX operates in multi-level
mode. The level-set grids follow all other
grids. If equal to 1, the level-set has two
levels (one additional level with higher
refinement).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">mfix.levelset__refinement</span></code></td>
<td>If <code class="docutils literal"><span class="pre">amr.max_level</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> this parameter is
ignored. Otherwise it sets the maximum
refinement of the level-set</td>
</tr>
</tbody>
</table>
<div class="section" id="how-mfix-exa-constructs-the-eb-geometry">
<h2>How MFiX-Exa Constructs the EB Geometry<a class="headerlink" href="#how-mfix-exa-constructs-the-eb-geometry" title="Permalink to this headline">¶</a></h2>
<p>Once a geometry is selected by <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">make_eb_geometry</span></span></code>, the procedure is
the same for (almost) all geometries. Also see the <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/EB.html#initializing-the-geometric-database">AMReX geometry
documentation</a> for information on how to construct new geometries:</p>
<ol class="arabic simple">
<li>Construct an implicit function representing the geometry (using the language
of constructive solid geometry). For example</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span> <span class="n">my_cyl</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">inside</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">gshop_cyl</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">my_cyl</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>(Optional) Construct the implicit function representing the EB seen by the
particles. This might deviate from the “standard” EB depending on the
specific application. In all standard cases used by mfix, this step is
omitted.</li>
<li>Call <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">build_eb_levels</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">gshop</span></span><span class="punctuation"><span class="pre">)</span></span></code> this function builds the EB levels
and fills the implicit function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MultiFab</span></span></code> (the later being used to
construct the level-set function). Note that this also makes the particle EB
levels point to the fluid eb levels.</li>
<li>(Optional, do this if you did 2.) Call
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">build_particle_eb_levels</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">gshop_part</span></span><span class="punctuation"><span class="pre">)</span></span></code> <strong>last</strong>. This will update
the particle EB levels.</li>
</ol>
</div>
<div class="section" id="mfix-s-eb-data-structures">
<h2>MFiX’s EB Data Structures<a class="headerlink" href="#mfix-s-eb-data-structures" title="Permalink to this headline">¶</a></h2>
<p>The <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span></code> class stores the following EB data:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//! EB levels representing fluid boundary conditions</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Level</span> <span class="o">*&gt;</span> <span class="n">eb_levels</span><span class="p">;</span>
<span class="c1">//! EB levels representing particle boundary conditions (same as</span>
<span class="c1">//! `mfix::eb_levels` but might include additional walls).</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Level</span> <span class="o">*&gt;</span> <span class="n">particle_eb_levels</span><span class="p">;</span>

<span class="c1">//! EB factory that lives on the fluid grids</span>
<span class="n">Vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">amrex</span><span class="o">::</span><span class="n">EBFArrayBoxFactory</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ebfactory</span><span class="p">;</span>
<span class="c1">//! EB factory that lives on the particle grids</span>
<span class="n">Vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">amrex</span><span class="o">::</span><span class="n">EBFArrayBoxFactory</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">particle_ebfactory</span><span class="p">;</span>
</pre></div>
</div>
<p>As discussed in the previous sub-section, the difference between
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">eb_levels</span></span></code> and <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">particle_eb_levels</span></span></code> enables the user to
specify a modfied EB geometry for particles only. Whereas the fluid sees the EB
geometry in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">eb_levels</span></span></code>. If no addition particle EB geometry is
specified (point 4 in the previous section), then
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">particle_eb_levels</span></span></code> points to <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">eb_levels</span></span></code>.</p>
<p>In the same spirit, the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ebfactory</span></span></code> is constructed over the fluid
grid and using the fluid EB levels, whereas <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">particle_ebfactory</span></span></code> is
constructed over the particle grid using the particle EB levels.</p>
</div>
<div class="section" id="a-note-about-constructing-eb-levels">
<h2>A note about constructing EB Levels<a class="headerlink" href="#a-note-about-constructing-eb-levels" title="Permalink to this headline">¶</a></h2>
<p>MFiX-Exa builds EB levels in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">build_eb_levels</span></span></code> (via
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">LSCore</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">F</span></span><span class="operator"><span class="pre">&gt;::</span></span><span class="name"><span class="pre">BuildEBLevel</span></span></code>)</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="p">(</span><span class="n">gshop</span><span class="p">,</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">required_crse_lev</span><span class="p">,</span> <span class="n">max_crse_level</span><span class="p">);</span>
<span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span> <span class="o">&amp;</span> <span class="n">ebis</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="o">::</span><span class="n">top</span><span class="p">();</span>
</pre></div>
</div>
<p>When building an EB level, the maximum coarsening level (<code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span>
<span class="name"><span class="pre">max_crse_level</span></span></code>) and the required coarsening level (<code class="code cpp c++ docutils literal"><span class="keyword type"><span class="pre">int</span></span>
<span class="name"><span class="pre">required_crse_lev</span></span></code>) need to be specified. The reason for this is that we need to
specify to which level of coarseness the EB is still defined. It might not be
immediately obvious, but the Poisson solver (used in the fluid solve) also
depends indirectly on these parameters. Thus changing these during EB level
creation might restrict how many levels the MLMG solver can use, and therefore
give slightly different answers in the fluid solve.</p>
</div>
</div>
<div class="section" id="local-mesh-refinement-at-walls">
<h1>Local Mesh Refinement at Walls<a class="headerlink" href="#local-mesh-refinement-at-walls" title="Permalink to this headline">¶</a></h1>
<p>MFiX-Exa has the capability of locally refining the computational grid near EBs.
This is done by tagging (in <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ErrorEst</span></span></code>) any cells with volume
fraction between 0 and 1. To enable local mesh refinement, set <code class="docutils literal"><span class="pre">amr.max_level</span></code>
to a value greater than 1. Note that the parameter <code class="docutils literal"><span class="pre">mfix.levelset__refinement</span></code>
is ignored on all cases except when <code class="docutils literal"><span class="pre">amr.max_level</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<div class="section" id="mfix-exa-initialization-process">
<h2>MFiX-Exa Initialization Process<a class="headerlink" href="#mfix-exa-initialization-process" title="Permalink to this headline">¶</a></h2>
<p>Since MFiX requires the volume fraction when building grids (because this is
needed by <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ErrorEst</span></span></code>), the EB geometries need to be built before
calling <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Init</span></span></code>. The recommended procedure therefore is</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Default constructor (geom[lev] is defined here)</span>
<span class="n">mfix</span> <span class="n">my_mfix</span><span class="p">;</span>

<span class="c1">// Initialize internals from ParamParse database</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">InitParams</span><span class="p">(</span><span class="n">solve_fluid</span><span class="p">,</span> <span class="n">solve_dem</span><span class="p">,</span> <span class="n">call_udf</span><span class="p">);</span>

<span class="c1">// Initialize memory for data-array internals</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">ResizeArrays</span><span class="p">();</span>

<span class="c1">// Construct EB (must be done _before_ mfix::Init)</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">make_eb_geometry</span><span class="p">();</span>

<span class="c1">// Initialize derived internals. Grids are create here.</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>

<span class="c1">// Create EB factories on new grids</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">make_eb_factories</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">solve_dem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Fill level-sets on each level (must be done _after_ mfix::Init)</span>
    <span class="n">my_mfix</span><span class="p">.</span><span class="n">fill_eb_levelsets</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Finish constructing levels</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">InitLevelData</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span><span class="n">time</span><span class="p">);</span>

<span class="c1">// Regrid (ensure all MultiFabs are on their correct grids)</span>
<span class="n">my_mfix</span><span class="p">.</span><span class="n">Regrid</span><span class="p">();</span>
</pre></div>
</div>
<p>Also note that mfix defines boundary conditions in Fortran also (via the
mfix.dat). Since these are potentially needed to build EB walls,
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">make_eb_geometry</span></span></code> also calls <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix_set_bc_type</span></span></code>.</p>
<p>The grids for each level are build in the <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Init</span></span></code> by invoking the
initialization functions inherited from <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">AmrCore</span></span></code>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// This tells the AmrMesh class not to iterate when creating the initial</span>
<span class="c1">// grid hierarchy</span>
<span class="n">SetIterateToFalse</span><span class="p">();</span>

<span class="c1">// This tells the Cluster routine to use the new chopping routine which</span>
<span class="c1">// rejects cuts if they don&#39;t improve the efficiency</span>
<span class="n">SetUseNewChop</span><span class="p">();</span>

<span class="c1">// This Builds the new Grids</span>
<span class="n">InitFromScratch</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-level-set-function">
<h1>The Level-Set Function<a class="headerlink" href="#the-level-set-function" title="Permalink to this headline">¶</a></h1>
<p>MFiX-Exa uses a level-set function to resolve particle-wall collisions. See the
<a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/EB.html#level-sets">AMReX Level-Set documentation</a> for more details. The level-set function is
stored on the nodal <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">unique_ptr</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">&gt;&gt;</span></span> <span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">level_sets</span></span></code>.
The level-set data is always stored on the particle grids. Depending on the
input <code class="docutils literal"><span class="pre">amr.max_level</span></code> The level-set can be in one of two modes:</p>
<ol class="arabic simple">
<li>MFiX-Exa is running in single-level mode (<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">nlev</span></span> <span class="operator"><span class="pre">==</span></span> <span class="literal number integer"><span class="pre">1</span></span></code>). Then
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">]</span></span></code> will be at the same resolution as the fluid
(except that it is stored on the particle grid). Even though <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">nlev</span></span> <span class="operator"><span class="pre">==</span></span> <span class="literal number integer"><span class="pre">1</span></span></code>,
there is a second level, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="literal number integer"><span class="pre">1</span></span><span class="punctuation"><span class="pre">]</span></span></code>. This level is the same as
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">]</span></span></code> but refined by <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">levelset__refinement</span></span></code>. This
way the level-set always has the appropriate resolution to resolve structures
in the EB, even if the fluid is defined on a fairly coarse grid.</li>
<li>MFiX-Exa is running in multi-level mode (<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">nlev</span></span> <span class="operator"><span class="pre">&gt;</span></span> <span class="literal number integer"><span class="pre">1</span></span></code>). The the parameter
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">levelset__refinement</span></span></code> is ignored. <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">mfix</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">level_sets</span></span></code> then
follows the rest of MFiX, i.e. it is defined on the particle grids on all
levels.</li>
</ol>
<p>The level-set is used in two places:</p>
<ol class="arabic simple">
<li>The function <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">MFIXParticleContainer</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">EvolveParticles</span></span></code> interpolates the
level-set onto each particle’s position in order to resolve collisions with
the EBs. If <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">nlev</span></span> <span class="operator"><span class="pre">==</span></span> <span class="literal number integer"><span class="pre">1</span></span></code>, <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="literal number integer"><span class="pre">1</span></span><span class="punctuation"><span class="pre">]</span></span></code> is used to evolve the
particle positions. Otherwise <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">lev</span></span><span class="punctuation"><span class="pre">]</span></span></code> is used for each level.</li>
<li>The fluid-particle coupling can sometimes rely on neighbor stencils where one
or more cell is covered by an EB. In order to avoid values that do not
conform with the boundary conditions, the fluid velocity is reconstructed in
those cells. The algorithm relies on the level-set, and uses
<code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">lev</span></span><span class="punctuation"><span class="pre">]</span></span></code> on each level.</li>
</ol>
<div class="section" id="special-cases-involving-level-sets">
<h2>Special Cases Involving Level-Sets<a class="headerlink" href="#special-cases-involving-level-sets" title="Permalink to this headline">¶</a></h2>
<p>The level-set function is filled by the <cite>mfix::fill_eb_levelsets()</cite> function.
There are two special cases involving level-sets:</p>
<ol class="arabic simple">
<li>Mass-Inflow boundary conditions are not given EB walls. However, we don’t
want particles to fall out of a MI either, so at the very end of the
<cite>mfix::fill_eb_levelsets()</cite> function we call <cite>mfix::intersect_ls_walls()</cite>.
This performs an intersection operation with the level-set representing a
wall at each MI.</li>
<li>Box geometries and regular geometries are comprised entirely out of planar
surfaces. Therefore the levelset is not construction out of an EB factory (as
would be the case for all other geometries). But out of an intersection with
all planar surfaces. This has the advantage of correctly describing corners.</li>
</ol>
</div>
<div class="section" id="fluid-reconstruction">
<h2>Fluid Reconstruction<a class="headerlink" href="#fluid-reconstruction" title="Permalink to this headline">¶</a></h2>
<p>The reconstruction algorithm is called whenever a cell in the particle’s
neighbor stencil is covered. For no-slip walls, the reconstructed velocity in
that cell is linearly extrapolated from the nearest “valid” fluid cell and 0 at
the wall. This way the fluid velocity is consistent with the no-slip boundary
condition along the normal to the EB. For a planar EB wall, the following would
be enough (the level-set is called <code class="code fortran docutils literal"><span class="name"><span class="pre">phi</span></span></code> here):</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span> <span class="n">is_covered_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>                         <span class="p">.</span><span class="nb">and</span><span class="p">.</span> <span class="p">&amp;</span>
<span class="p">&amp;</span>   <span class="nb">minval</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">phi_threshold</span> <span class="p">)</span> <span class="k">then</span>

    <span class="c">! Coordinates of cell center</span>
    <span class="n">x_cc</span> <span class="o">=</span> <span class="p">(</span> <span class="kt">real</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">],</span><span class="n">rt</span><span class="p">)</span> <span class="o">+</span> <span class="n">half</span> <span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>

    <span class="c">! Get phi at cell center</span>
    <span class="k">call </span><span class="n">amrex_eb_interp_levelset</span><span class="p">(</span><span class="n">x_cc</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n_refine</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span> <span class="n">phhi</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">phi_cc</span><span class="p">)</span>

    <span class="c">! Get normal at cell center</span>
    <span class="k">call </span><span class="n">amrex_eb_normal_levelset</span><span class="p">(</span><span class="n">x_cc</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n_refine</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span> <span class="n">phhi</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">norm_cc</span><span class="p">)</span>

    <span class="c">! Initial guess of interpolation point:</span>
    <span class="n">x_i</span>  <span class="o">=</span> <span class="n">x_cc</span> <span class="o">+</span> <span class="n">two</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi_cc</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm_cc</span>

    <span class="c">! Get phi at interpolation point</span>
    <span class="k">call </span><span class="n">amrex_eb_interp_levelset</span><span class="p">(</span><span class="n">x_i</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n_refine</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span> <span class="n">phhi</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">phi_i</span><span class="p">)</span>

    <span class="c">! Compute interpolated velocity at x_i</span>
    <span class="n">vel_i</span> <span class="o">=</span> <span class="n">trilinear_interp</span><span class="p">(</span><span class="n">vel_in</span><span class="p">,</span> <span class="n">vilo</span><span class="p">,</span> <span class="n">vihi</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>

    <span class="c">! Since interpolation point is only slightly shifted with respect to</span>
    <span class="c">! the mirror point, we approximate vel at mirror point with vel_i and</span>
    <span class="c">! then use linear interpolation between x_m and x_c</span>

    <span class="n">vel_out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,:)</span> <span class="o">=</span> <span class="n">vel_i</span> <span class="o">*</span> <span class="n">phi_cc</span> <span class="o">/</span> <span class="n">phi_i</span>
</pre></div>
</div>
<p>If the EB represents a curved wall, the initial normal is not a good estimate
for the normal at the closest point on the wall. Therefore we start a the
covered cell, and “walking” along the EB normal on cell at a time (computed from
the level-set function), until the neighbor stencil does not include covered
cells:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="c">! Find location of interpolation point by iteration if necessary</span>
<span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">find_xi</span><span class="p">:</span> <span class="k">do</span>

<span class="k">    if</span> <span class="p">(</span> <span class="n">interp_stencil_is_valid</span><span class="p">(</span><span class="n">x_i</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">flo</span><span class="p">,</span> <span class="n">fhi</span><span class="p">)</span> <span class="p">)</span> <span class="k">exit </span><span class="n">find_xi</span>

    <span class="c">! Get normal at interpolation point</span>
    <span class="k">call </span><span class="n">amrex_eb_normal_levelset</span><span class="p">(</span><span class="n">x_i</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n_refine</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span> <span class="n">phhi</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">norm_i</span><span class="p">)</span>

    <span class="n">x_i</span> <span class="o">=</span> <span class="n">x_i</span> <span class="o">+</span> <span class="nb">maxval</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm_i</span>

    <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">iter</span> <span class="o">&gt;</span> <span class="n">max_iter</span> <span class="p">)</span> <span class="p">&amp;</span>
        <span class="k">call </span><span class="n">amrex_abort</span><span class="p">(</span><span class="s2">&quot;reconstruct_velocity(): cannot find interpolation point&quot;</span><span class="p">)</span>

<span class="k">end do </span><span class="n">find_xi</span>
</pre></div>
</div>
<p>Note that the level-set here needs to be at the same resolution as the fluid.
This is the reason why we need to keep the coarse level <code class="code cpp c++ docutils literal"><span class="name"><span class="pre">level_sets</span></span><span class="punctuation"><span class="pre">[</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">]</span></span></code>
even when running in single-level mode.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="EB.html" class="btn btn-neutral" title="Embedded Boundaries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, MFiX-Exa Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>